# Copyright (c) 2025 sakib-maho
# Licensed under the MIT License
# See LICENSE file for details

# -*- coding: utf-8 -*-
"""Hill Climbing Search .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LyN5Vxv7BN7HEt78-qNxbrCr8gcFJyx6
"""

#Steepest Ascent
state =  [4, 78, 90, 9999, 0, -88, -76]

def calc_cost(state):
    cost = 0
    flag = 1
    for i in range(len(state)):
        for j in range(len(state)):
            try:
                if state[i] > state[j+flag]:
                    cost = cost + 1
            except:
                pass
        flag = flag + 1
    return cost


def state_generation(state, cost):
    copy = state[:]
    flag1 = 1
    new_path = state[:]
    #costt = cost
    decision = False
    for i in range(len(state)):
        for j in range(len(state)):
            try:
                state[i], state[flag1+j] = state[flag1+j], state[i]
                new_cost = calc_cost(state)
                print(f"Path:{state} and cost : {new_cost}")
                if new_cost < cost:
                    cost = new_cost
                    new_path = state
                    decision = True
                state = copy[:]
            #print(f"has to change{state}")
            except:
                pass
        flag1 = flag1 + 1

    #print(f"Path:{new_path} Low cost:{costt}")
    if decision:
        return new_path, cost
    else:
        return copy, None


def goal_test(state):
    if calc_cost(state) == 0:
        return 1
    else:
        return False


cost = calc_cost(state)
print(f"Original List:{state}")
while goal_test(state) != 1:
    state, cost = state_generation(state, cost)
    # When you are stuck, your cost will be None
    if cost is None:
        print(state)
        break
print("============================================================")
print("=========================Solution===========================")
print("============================================================")
print(f"Solutation Path:{state} Cost:{cost}")
print("============================================================")
print("============================================================")
#		break

#Simulated Annealing
import math
import random
state = [4, 78, 0, -88, -76]


def calc_cost(state):
    cost = 0
    flag = 1
    for i in range(len(state)):
        for j in range(len(state)):
            try:
                if state[i] > state[j+flag]:
                    cost = cost + 1
            except:
                pass
        flag = flag + 1
    return cost


def moveORnot(delE):
    value = math.exp(delE)
    x = random.uniform(0, 1)
    if x <= value:
        return 1
    else:
        return 0



def state_generation(state, cost):
    copy = state[:]
    flag1 = 1
    new_path = state[:]
    costt = calc_cost(state)
    for i in range(len(state)):
        for j in range(len(state)):
            try:
                state[i], state[flag1+j] = state[flag1+j], state[i]
                new_cost = calc_cost(state)
                print(f"Path:{state} and cost : {new_cost}")
                if new_cost < costt:
                    costt = new_cost
                    new_path = state
                    return new_path, costt
                elif new_cost == costt:
                    delE = -1
                    dession = moveORnot(delE)
                    if dession == 1:
                        new_path = state
                        costt = new_cost
                        return new_path, costt
                else:
                    delE = costt - new_cost
                    dession = moveORnot(delE)
                    if dession == 1:
                        new_path = state
                        costt = new_cost
                        return new_path, costt
                state = copy[:]
                #print(f"has to change{state}")
            except:
                pass
        flag1 = flag1 + 1
        #return new_path, None

#print(f"Path:{new_path} Low cost:{costt}")
    return state, None



def goal_test(state):
    if calc_cost(state) == 0:
        return 1
    else:
        return 0


cost = calc_cost(state)


while goal_test(state) != 1:
    state, cost = state_generation(state, cost)
    # When you are stuck, your cost will be None
    if cost is None:
        print(state)
        exit()
print("============================================================")
print("=========================Solution===========================")
print("============================================================")
print(f"Solution Path:{state} Cost:{cost}")
print("============================================================")
print("============================================================")
#break

#Simulated Annealing
import math
import random
state = [4, 78, 90, 9999, 0, -88, -76]


def calc_cost(state):
    cost = 0
    flag = 1
    for i in range(len(state)):
        for j in range(len(state)):
            try:
                if state[i] > state[j+flag]:
                    cost = cost + 1
            except:
                pass
        flag = flag + 1
    return cost


def moveORnot(delE):
    value = math.exp(delE)
    x = random.uniform(0, 1)
    if x <= value:
        return 1
    else:
        return 0



def state_generation(state, cost):
    copy = state[:]
    flag1 = 1
    new_path = state[:]
    costt = calc_cost(state)
    for i in range(len(state)):
        for j in range(len(state)):
            try:
                state[i], state[flag1+j] = state[flag1+j], state[i]
                new_cost = calc_cost(state)
                print(f"Path:{state} and cost : {new_cost}")
                if new_cost < costt:
                    costt = new_cost
                    new_path = state
                    return new_path, costt
                elif new_cost == costt:
                    delE = -1
                    dession = moveORnot(delE)
                    if dession == 1:
                        new_path = state
                        costt = new_cost
                        return new_path, costt
                else:
                    delE = costt - new_cost
                    dession = moveORnot(delE)
                    if dession == 1:
                        new_path = state
                        costt = new_cost
                        return new_path, costt
                state = copy[:]
                #print(f"has to change{state}")
            except:
                pass
        flag1 = flag1 + 1
        #return new_path, None

#print(f"Path:{new_path} Low cost:{costt}")
    return state, None



def goal_test(state):
    if calc_cost(state) == 0:
        return 1
    else:
        return 0


cost = calc_cost(state)


while goal_test(state) != 1:
    state, cost = state_generation(state, cost)
    # When you are stuck, your cost will be None
    if cost is None:
        print(state)
        exit()
print("============================================================")
print("=========================Solution===========================")
print("============================================================")
print(f"Solution Path:{state} Cost:{cost}")
print("============================================================")
print("============================================================")
#break